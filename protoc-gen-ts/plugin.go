package main

import (
	"bytes"
	"fmt"
	"github.com/golang/protobuf/proto"
	desc "github.com/golang/protobuf/protoc-gen-go/descriptor"
	ppb "github.com/golang/protobuf/protoc-gen-go/plugin"
	"io"
	"os"
	"path/filepath"
	"strings"
)

const genDebug = false

func main() {
	var buf bytes.Buffer
	_, err := buf.ReadFrom(os.Stdin)
	if err != nil {
		panic(fmt.Errorf("error reading from stdin: %v", err))
	}
	out, err := codeGenerator(buf.Bytes())
	if err != nil {
		panic(err)
	}
	os.Stdout.Write(out)
}

func codeGenerator(b []byte) ([]byte, error) {
	req := ppb.CodeGeneratorRequest{}
	err := proto.Unmarshal(b, &req)
	if err != nil {
		return nil, fmt.Errorf("error unmarshaling CodeGeneratorRequest: %v", err)
	}
	resp := gen(&req)
	out, err := proto.Marshal(resp)
	if err != nil {
		return nil, fmt.Errorf("error marshaling CodeGeneratorResponse: %v", err)
	}
	return out, nil
}

func gen(req *ppb.CodeGeneratorRequest) *ppb.CodeGeneratorResponse {
	resp := &ppb.CodeGeneratorResponse{}
	fileToGenerate := map[string]bool{}
	for _, f := range req.FileToGenerate {
		fileToGenerate[f] = true
	}
	genService := strings.Contains(req.GetParameter(), "plugin=grpc")

	rootns := NewEmptyNamespace()
	for _, fdp := range req.ProtoFile {
		if fdp.GetSyntax() != "proto3" {
			panic(fmt.Errorf("unsupported syntax: %s in file %s", fdp.GetSyntax(), fdp.GetName()))
		}
		rootns.Parse(fdp)
		// panic(rootns.PrettyPrint()) // for debuggling

		if !fileToGenerate[fdp.GetName()] {
			continue
		}
		f := &ppb.CodeGeneratorResponse_File{}

		fext := filepath.Ext(fdp.GetName())
		fname := strings.TrimSuffix(fdp.GetName(), fext) + "_pb.ts"
		f.Name = proto.String(fname)

		b := &bytes.Buffer{}
		w := &writer{b, 0}
		writeFile(w, fdp, rootns, genService)
		f.Content = proto.String(b.String())
		resp.File = append(resp.File, f)
	}
	return resp
}

func writeFile(w *writer, fdp *desc.FileDescriptorProto, rootNs *Namespace, genService bool) {
	ns := rootNs.FindFullyQualifiedNamespace("." + fdp.GetPackage())
	if ns == nil {
		panic("unable to find namespace for: " + fdp.GetPackage())
	}
	w.p("// Generated by the protocol buffer compiler.  DO NOT EDIT!")
	w.p("// Source: %s", fdp.GetName())
	w.ln()
	// Messages, recurse.
	for _, dp := range fdp.MessageType {
		writeDescriptor(w, dp, ns, nil)
	}
}

type field struct {
	fd *desc.FieldDescriptorProto
}

func newField(fd *desc.FieldDescriptorProto, ns *Namespace) *field {
	f := &field{
		fd: fd,
	}
	return f
}

func (f field) isOneofMember() bool {
	return false
	// return f.fd.OneofIndex != nil
}

func (f field) varName() string {
	return f.fd.GetName()
}

func (f field) tsType() string {
	switch t := *f.fd.Type; t {
	case desc.FieldDescriptorProto_TYPE_STRING, desc.FieldDescriptorProto_TYPE_BYTES:
		return "string"
	case desc.FieldDescriptorProto_TYPE_INT64,
		desc.FieldDescriptorProto_TYPE_INT32, desc.FieldDescriptorProto_TYPE_UINT64, desc.FieldDescriptorProto_TYPE_UINT32, desc.FieldDescriptorProto_TYPE_SINT64, desc.FieldDescriptorProto_TYPE_SINT32, desc.FieldDescriptorProto_TYPE_FIXED32, desc.FieldDescriptorProto_TYPE_FIXED64, desc.FieldDescriptorProto_TYPE_SFIXED32, desc.FieldDescriptorProto_TYPE_SFIXED64:
		return "number" // TODO BigInt
	case desc.FieldDescriptorProto_TYPE_FLOAT, desc.FieldDescriptorProto_TYPE_DOUBLE:
		return "number"
	case desc.FieldDescriptorProto_TYPE_BOOL:
		return "boolean"
	case desc.FieldDescriptorProto_TYPE_MESSAGE:
		// return f.typePhpNs + "\\" + f.typePhpName
		return "number"
	case desc.FieldDescriptorProto_TYPE_ENUM:
		// return f.typePhpNs + "\\" + specialPrefix + f.typePhpName + "_t"
		return "number"
	default:
		panic(fmt.Errorf("unexpected proto type while converting to php type: %v", t))
	}

}

func (f field) labeledType() string {
	/*if f.isMap {
		k, v := f.mapFields()
		kt := k.phpType()
		if f.isMapWithBoolKey() {
			kt = fmt.Sprintf("%s\\bool_map_key_t", libNsInternal)
		}
		return fmt.Sprintf("dict<%s, %s>", kt, v.labeledType())
	}*/
	if f.isRepeated() {
		return f.tsType() + "[]"
	}
	if f.fd.GetType() == desc.FieldDescriptorProto_TYPE_MESSAGE {
		return f.tsType()
	}
	return f.tsType()
}

func (f field) isRepeated() bool {
	return *f.fd.Label == desc.FieldDescriptorProto_LABEL_REPEATED
}

func writeDescriptor(w *writer, dp *desc.DescriptorProto, ns *Namespace, prefixNames []string) {
	fields := []*field{}
	for _, fd := range dp.Field {
		fields = append(fields, newField(fd, ns))
	}

	nextNames := append(prefixNames, dp.GetName())
	name := strings.Join(nextNames, "_")
	w.p("export class %s {", name)
	for _, f := range fields {
		if f.isOneofMember() {
			continue
		}
		w.p("%s: %s;", f.varName(), f.labeledType())
	}
	w.p("}")
	w.ln()
}

// writer is a little helper for output printing. It indents code
// appropriately among other things.
type writer struct {
	w io.Writer
	i int
}

func (w *writer) p(format string, a ...interface{}) {
	if strings.HasPrefix(format, "}") {
		w.i--
	}
	i := w.i
	if i < 0 {
		i = 0
	}
	indent := strings.Repeat("  ", i)
	fmt.Fprintf(w.w, indent+format, a...)
	w.ln()
	if strings.HasSuffix(format, "{") {
		w.i++
	}
}

func (w *writer) ln() {
	fmt.Fprintln(w.w)
}

func (w *writer) pdebug(format string, a ...interface{}) {
	if !genDebug {
		return
	}
	w.p(fmt.Sprintf(`console.log("PROTOC-DEBUG: %s");`, format), a...)
}
